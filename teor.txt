основные требования

целостность
отказоустойчивость (бекап, резервная копия)
согласованность
масштабируемость

локальные ис - правильно стыковать данные для различных пользователей, с БД работает 1 человек (+курсовая)

файл-ерверные ис - несколько человек, но не оч 

клиент-серверные ис - часть 1 серверная - машина сервер (основная работа),
2 - субд клиент(разгранич клиент, обращается куда только можно и все приват и публик), 
по сети идут толко нужные данные, разделение доступа

типы ис:
-иерархические
-сетевые
-реляционные
-объектно-ориентированнные 

обозначения:

сущность - объект
кортеж, запись - строка таблицы
атрибут - название столбца или поля

про ключевые поля надо почитать

реляционная БД: 

БД где одна таблика связана со второй (в первой допустим колонка транспорт и цифры 1,2,3, а другоая таблица будет содержать 1 - трамвай, 2 - автобус, 3 - троллейбус, потом можно еще одну добавить)

какая связь 1к1 или 1к_беск

в базе данных айдишники не должны ломаться

кросс джоин
также проверь есть ли защита с sql инъекция чтобы все наружу не вываливалось


Твой файл Collection.cpp — это «Завхоз» твоей базы данных. 
Его задача — физически управлять файлами на жестком диске. 
Он не знает про SQL, он просто выполняет приказы: 
«Создай папку», «Запиши строку», «Удали строку».

файл (Database.cpp) — это «Главный пульт управления» твоей СУБД.
Его задача — собрать вместе схему и SQL-процессор и предоставить интерфейс. 
создается один объект Database и говоришь ему: «Выполни запрос».

Этот файл (Schema.cpp) отвечает за структуру твоей базы данных. 
Он читает файл schema.json, запоминает, какие есть таблицы и колонки, 
и физически создает папки для них на диске.

Этот файл SQLProcessor.cpp — это «Мозг» твоей СУБД. 
Именно здесь текст SQL-запроса (SELECT) превращается в реальные действия 
(открыть файл, найти строки, сравнить их).

Библиотека nlohman нужна для парсинга (чтения) конфигурационного файла schema.json.
Твоя СУБД должна знать структуру базы данных: какие есть таблицы, 
какие в них колонки и какой лимит строк.
C++ "из коробки" не умеет читать JSON. 
Если бы не эта библиотека, тебе пришлось бы писать свой парсер текста: 
искать фигурные скобки {}, кавычки "", 
запятые и двоеточия вручную. Это очень сложно и долго. 
Библиотека делает это за одну строчку.

Где реализуется:
json data;   // 1. Создание пустой переменной типа json
f >> data;   // 2. Считывание текста из файла f и превращение его в структуру

this->name = data["name"];                 // Достаем имя базы
this->tuples_limit = data["tuples_limit"]; // Достаем лимит строк
auto structure = data["structure"];        // Достаем объект со структурой таблиц

Нужна чтобы загружать структуру базы данных из файла schema.json. 
Это позволяет менять структуру таблиц без перекомпиляции программы.

Библиотека загружает файл в объект json (универсальный контейнер, можно хранить любой тип) data, 
который ведет себя как std::map. 
Я обращаюсь к полям по ключам (например, data["structure"])
и преобразую их в типы C++.