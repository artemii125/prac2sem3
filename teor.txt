основные требования

целостность
отказоустойчивость (бекап, резервная копия)
согласованность
масштабируемость

локальные ис - правильно стыковать данные для различных пользователей, с БД работает 1 человек (+курсовая)

файл-ерверные ис - несколько человек, но не оч 

клиент-серверные ис - часть 1 серверная - машина сервер (основная работа),
2 - субд клиент(разгранич клиент, обращается куда только можно и все приват и публик), 
по сети идут толко нужные данные, разделение доступа

типы ис:
-иерархические
-сетевые
-реляционные
-объектно-ориентированнные 

обозначения:

сущность - объект
кортеж, запись - строка таблицы
атрибут - название столбца или поля

про ключевые поля надо почитать

реляционная БД: 

БД где одна таблика связана со второй (в первой допустим колонка транспорт и цифры 1,2,3, а другоая таблица будет содержать 1 - трамвай, 2 - автобус, 3 - троллейбус, потом можно еще одну добавить)

какая связь 1к1 или 1к_беск

в базе данных айдишники не должны ломаться

кросс джоин
также проверь есть ли защита с sql инъекция чтобы все наружу не вываливалось


Твой файл Collection.cpp — это «Завхоз» твоей базы данных. 
Его задача — физически управлять файлами на жестком диске. 
Он не знает про SQL, он просто выполняет приказы: 
«Создай папку», «Запиши строку», «Удали строку».

файл (Database.cpp) — это «Главный пульт управления» твоей СУБД.
Его задача — собрать вместе схему и SQL-процессор и предоставить интерфейс. 
создается один объект Database и говоришь ему: «Выполни запрос».

Этот файл (Schema.cpp) отвечает за структуру твоей базы данных. 
Он читает файл schema.json, запоминает, какие есть таблицы и колонки, 
и физически создает папки для них на диске.

Этот файл SQLProcessor.cpp — это «Мозг» твоей СУБД. 
Именно здесь текст SQL-запроса (SELECT) превращается в реальные действия 
(открыть файл, найти строки, сравнить их).

Библиотека nlohman нужна для парсинга (чтения) конфигурационного файла schema.json.
Твоя СУБД должна знать структуру базы данных: какие есть таблицы, 
какие в них колонки и какой лимит строк.
C++ "из коробки" не умеет читать JSON. 
Если бы не эта библиотека, тебе пришлось бы писать свой парсер текста: 
искать фигурные скобки {}, кавычки "", 
запятые и двоеточия вручную. Это очень сложно и долго. 
Библиотека делает это за одну строчку.

Где реализуется:
json data;   // 1. Создание пустой переменной типа json
f >> data;   // 2. Считывание текста из файла f и превращение его в структуру

this->name = data["name"];                 // Достаем имя базы
this->tuples_limit = data["tuples_limit"]; // Достаем лимит строк
auto structure = data["structure"];        // Достаем объект со структурой таблиц

Нужна чтобы загружать структуру базы данных из файла schema.json. 
Это позволяет менять структуру таблиц без перекомпиляции программы.

Библиотека загружает файл в объект json (универсальный контейнер, можно хранить любой тип) data, 
который ведет себя как std::map. 
Я обращаюсь к полям по ключам (например, data["structure"])
и преобразую их в типы C++.


теория практика 2 (сети)

Клиент-сервер - модель, где:
- **Сервер** - программа, которая ждет запросы и обрабатывает их
- **Клиент** - программа, которая отправляет запросы и получает ответы
- **TCP/IP** - протокол передачи данных по сети

Сокет - конечная точка для обмена данными между процессами.
- **TCP (SOCK_STREAM)** - надежная передача с установкой соединения

### Жизненный цикл сокета:

#### Сервер:
1. socket()    -> Создать сокет
2. bind()      -> Привязать к адресу (IP + порт 7432)
3. listen()    -> Начать слушать подключения
4. accept()    -> Принять клиента (блокируется до подключения)
5. recv/send   -> Обмен данными
6. close()     -> Закрыть соединение


#### Клиент:
1. socket()    -> Создать сокет
2. connect()   -> Подключиться к серверу (IP + порт)
3. send/recv   -> Обмен данными
4. close()     -> Закрыть соединение


## Ключевые концепции:
1. Сокет - механизм обмена данными между процессами
2. TCP - надежный протокол с установкой соединения
3. Клиент-сервер - архитектура распределенных систем
4. Многопоточность - параллельная обработка клиентов
5. Мьютекс - защита от конкурентного доступа к ресурсам
6. Блокирующие вызовы - функции, которые ждут событий
7. Буферизация - временное хранение данных при передаче


## Порядок байтов (Endianness)
Разные процессоры хранят числа по-разному:

### Little-Endian (Intel):
Число 7432 = 0x1D08
Память: [08] [1D]  ← младший байт первым

### Big-Endian (сеть):
Число 7432 = 0x1D08
Память: [1D] [08]  ← старший байт первым


### Функции конвертации:
htons(7432)  // Host TO Network Short - для портов
htonl(ip)    // Host TO Network Long - для IP
ntohs(port)  // Network TO Host Short
ntohl(ip)    // Network TO Host Long

тоесть у сервера есть свои 1+N (кол-во потоков) сокета (конечная точка обмена данными в сети),
один всегда слушает, а второй получает и отдает,
у клиента только один сокет,
они полключенны к одному порту сервера, но имеют свой порт, данные сервер-клиент передаются по протоколу TCP (гарантиованная установка соединения),
разрешение рейс кондишна многопоточности реализованно через мютекс блокировки
